<style>
    body {
      margin: 0;
      overflow: hidden;
    }
  
    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      font-size: 24px;
      z-index: 1;
    }
  </style>
  
  <div id="score">Score: 0</div>
  
  <script
    async
    src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
  ></script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
      }
    }
  </script>
  
  <script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js'
  
    const scene = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    )
  
    const renderer = new THREE.WebGLRenderer()
    renderer.setSize(window.innerWidth, window.innerHeight)
    document.body.appendChild(renderer.domElement)
  
    const controls = new OrbitControls(camera, renderer.domElement)
  
    let score = 0;
    const scoreElement = document.getElementById('score');
  
    class Box extends THREE.Mesh {
      constructor({
        width,
        height,
        depth,
        color = '#00ff00',
        velocity = {
          x: 0,
          y: 0,
          z: 0
        },
        position = {
          x: 0,
          y: 0,
          z: 0
        }
      }) {
        super(
          new THREE.BoxGeometry(width, height, depth),
          new THREE.MeshBasicMaterial({ color })
        )
  
        this.width = width
        this.height = height
        this.depth = depth
  
        this.position.set(position.x, position.y, position.z)
  
        this.bottom = this.position.y - this.height / 2;
        this.top = this.position.y + this.height / 2;
  
        this.velocity = velocity
      }
  
      update() {
        this.bottom = this.position.y - this.height / 2;
        this.top = this.position.y + this.height / 2;
  
        this.position.y += this.velocity.y;
        this.position.x += this.velocity.x;
        this.position.z += this.velocity.z;
  
        if (this.bottom <= ground.top) this.velocity.y = 0
      }
  
      checkCollision(other) {
        return (
          Math.abs(this.position.x - other.position.x) < (this.width + other.width) / 2 &&
          Math.abs(this.position.y - other.position.y) < (this.height + other.height) / 2 &&
          Math.abs(this.position.z - other.position.z) < (this.depth + other.depth) / 2
        );
      }
    }
  
    const player = new Box({
      width: 1,
      height: 1,
      depth: 1,
      velocity: {
        x: 0,
        y: 0,
        z: -0.05
      }
    });
    scene.add(player);
  
    const ground = new THREE.Group();
    scene.add(ground);
  
    const obstacles = new THREE.Group();
    scene.add(obstacles);
  
    const createGroundSegment = (z) => {
      const segment = new Box({
        width: 9,
        height: 0.5,
        depth: 10,
        color: '#808080',
        position: {
          x: 0,
          y: -2,
          z
        }
      });
      ground.add(segment);
  
      const laneColors = ['#ff0000', '#00ff00', '#0000ff'];
  
      for (let i = 0; i < 3; i++) {
        const lane = new Box({
          width: 3,
          height: 0.6,
          depth: 10,
          color: laneColors[i],
          position: {
            x: -3 + i * 3,
            y: -2.25,
            z
          }
        });
        ground.add(lane);
      }
    }
  
    const createObstacleLine = (z) => {
      const greenLane = Math.floor(Math.random() * 3);
      for (let i = 0; i < 3; i++) {
        const color = i === greenLane ? '#00ff00' : '#ff0000';
  
        const obstacle = new Box({
          width: 1,
          height: 1,
          depth: 1,
          color,
          position: {
            x: -3 + i * 3,
            y: 0,
            z
          }
        });
  
        obstacles.add(obstacle);
      }
    }
  
    for (let i = 0; i < 10; i++) {
      createGroundSegment(-10 * i);
    }
  
    // Create the first obstacle line
    createObstacleLine(-50);
  
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.y = 3;
    light.position.z = 2;
    scene.add(light);
  
    const keys = {
      a: {
        pressed: false
      },
      d: {
        pressed: false
      }
    }
  
    window.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'KeyA':
          keys.a.pressed = true
          break
        case 'KeyD':
          keys.d.pressed = true
          break
      }
    })
  
    window.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'KeyA':
          keys.a.pressed = false
          break
        case 'KeyD':
          keys.d.pressed = false
          break
      }
    })
  
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
  
      // Infinite ground
      ground.children.forEach(segment => {
        segment.position.z += 0.05;
        if (segment.position.z > camera.position.z + 10) {
          segment.position.z -= 100;
        }
      });
  
      // Move player forward
      player.position.z -= 0.05;
  
      // Move player sideways
      if (keys.a.pressed && player.position.x > -3) {
        player.position.x -= 3;
        keys.a.pressed = false;
      } else if (keys.d.pressed && player.position.x < 3) {
        player.position.x += 3;
        keys.d.pressed = false;
      }
  
      player.update();
  
      // Check collisions with obstacles
      obstacles.children.forEach(obstacle => {
        obstacle.position.z += 0.05;
  
        if (obstacle.position.z > camera.position.z + 10) {
          obstacles.remove(obstacle);
          createObstacleLine(obstacle.position.z - 250); // Spawn a new obstacle line further ahead
        }
  
        if (player.checkCollision(obstacle)) {
          if (obstacle.material.color.getHexString() === '00ff00') {
            score++;
            scoreElement.innerText = `Score: ${score}`;
            obstacles.remove(obstacle);
          } else {
            alert("Game Over! Final Score: " + score);
            window.location.reload();
          }
        }
      });
  
      // Camera follows player
      camera.position.x = player.position.x;
      camera.position.y = player.position.y + 2;
      camera.position.z = player.position.z + 5;
      camera.lookAt(player.position);
    }
  
    animate()
  </script>
  